// source

void spmv(DTYPE data_in[NUM_INPUTS][MAX_LEN], DTYPE y[SIZE])
{
	L1: for (int i = 0; i < NUM_ROWS; i++) {
#pragma HLS PIPELINE off
		DTYPE y0 = 0;
		L2: for (int k = (int)data_in[0][i]; k < (int)data_in[0][i+1]; k++) {
#pragma HLS PIPELINE off

			y0 += data_in[1][k] * data_in[3][(int)data_in[2][k]];

		}
		y[i] = y0;
	}
}

//tb

//
// Created by Ghala Buarish on 7/17/25.
//
#include "CSR_baseline.h"
#include <stdio.h>
void matrixvector(DTYPE A[SIZE][SIZE], DTYPE * y, DTYPE * x)
{
	for (int i = 0; i < SIZE; i++) {
		DTYPE y0 = 0;
		for (int j = 0; j < SIZE; j++)
			y0 += A[i][j] * x[j];
		y[i] = y0;
	}
}

int main(){
	int fail = 0;
	DTYPE M[SIZE][SIZE] = {{3,4,0,0},{0,5,9,0},{2,0,3,1},{0,4,0,6}};
	DTYPE x[SIZE] = {1,2,3,4};
	DTYPE y_sw[SIZE];
	DTYPE values[] = {3,4,5,9,2,3,1,4,6};
	int columnIndex[] = {0,1,1,2,0,2,3,1,3};
	int rowPtr[] = {0,2,4,7,9};
	DTYPE y[SIZE];

	DTYPE data_in[NUM_INPUTS][MAX_LEN];

	for(int i=0; i<NUM_ROWS+1;i++)
		data_in[0][i] = (DTYPE)rowPtr[i];

	for(int i=0; i<NNZ; i++)
		data_in[1][i] = values[i];

	for(int i=0; i<NNZ; i++)
		data_in[2][i] = (DTYPE)columnIndex[i];

	for(int i=0; i< SIZE; i++)
		data_in[3][i] = x[i];


	// spmv(rowPtr, columnIndex, values, y, x);

	spmv(data_in, y);

	matrixvector(M, y_sw, x);
	for(int i = 0; i < SIZE; i++)
		if(y_sw[i] != y[i])
			fail = 1;
	if(fail == 1)
		printf("FAILED\n");
	else
		printf("PASS\n");
	return fail;
}


//header
//
// Created by Ghala Buarish on 7/17/25.
//

#ifndef CSR_BASELINE_H
#define CSR_BASELINE_H


const static int SIZE = 4;       // Size of square matrix (4x4)
const static int NNZ = 9;        // Number of non-zero elements
const static int NUM_ROWS = 4;   // Number of rows (same as SIZE)
const static int NUM_INPUTS = 4;
const static int MAX_LEN = 9;

typedef float DTYPE;


// void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ],
// 		  DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]);


void spmv(DTYPE data_in[SIZE], DTYPE y[SIZE])

#endif // CSR_BASELINE_H


